{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;\red255\green255\blue255;\red255\green236\blue130;
}
{\*\expandedcolortbl;;\cssrgb\c12941\c12941\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c100000\c93333\c58039;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl340\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 SOLID:\
\'a0\
SOLID is one of the\'a0\cb4 m\cb3 ost popular sets of design principles in object-oriented software development.\
\'a0\
It\'92s a\'a0\cb4 m\cb3 nemonic acronym for the following five design principles:\
\'a0\
1.Single Responsibility Principle\
2.Open/Closed Principle\
3.Liskov Substitution Principle\
4.Interface Segregation Principle\
5.Dependency Inversion\
\'a0\
\'a0\
1.SRP->Single Responsibility Principle\
\'a0\
The Single Responsibility Principle (SRP) states that each software\'a0\cb4 m\cb3 odule should have one and only one reason to change.\
\'a0\
Software\'a0\cb4 M\cb3 odule:\
\'a0\'a0 Could be class | function(\cb4 m\cb3 ethod) | (package-java) (namespace-C#) (\cb4 M\cb3 odule -JS).\
\'a0\
\'a0\
public class Employee \{\
\'a0 public\'a0\cb4 M\cb3 oney calculatePay();\
\'a0 public void save();\
\'a0 public String reportHours();\
\}\
\'a0\
public class PayCalculator\{\
\'a0\'a0 public\'a0\cb4 M\cb3 oney calculatePay();\
\}\
public class EmplyeeDAO\{\
\'a0 public void save();\
\}\
\'a0\
public class AttendanceCalculator\{\
public\'a0\cb4 M\cb3 oney calculatePay();\
\}\
\'a0\
\'a0\
"Gather together the things that change for the same reasons. Separate those things that change for different reasons."\
\'a0\
\'a0\
Hands On:\
Apply SRP on ProfileService.\
\'a0\
ProfileService is already locked with fetch logic,refactor code using SRP princple.\
///////////////////////////////////////////////////////////////\
\'a0\
O-Open-closed Principle:\
.......................\
\'a0\
\'93Software entities (classes,\'a0\cb4 m\cb3 odules, functions, etc.) should be open for extension, but closed for\'a0\cb4 m\cb3 odification.\'94\
\'a0\
The general idea of this principle is great. It tells you to write your code so that you will be able to add new functionality without changing the existing code. That prevents situations in which a change to one of your classes also requires you to adapt all depending classes. Unfortunately, Bertrand\'a0\cb4 M\cb3 ayer proposes to use inheritance to achieve this goal\
\'a0\
That\'92s why Robert C.\'a0\cb4 M\cb3 artin and others redefined the Open/Closed Principle to the Polymorphic Open/Closed Principle. It uses interfaces instead of superclasses to allow different implementations which you can easily substitute without changing the code that uses them. The interfaces are closed for\'a0\cb4 m\cb3 odifications, and you can provide new implementations to extend the functionality of your software.\
\'a0\
The\'a0\cb4 m\cb3 ain benefit of this approach is that an interface introduces an additional level of abstraction which enables loose coupling. The implementations of an interface are independent of each other and don\'92t need to share any code. If you consider it beneficial that two implementations of an interface share some code, you can either use inheritance or composition.\
\'a0\
interface Calculator\{\
calculate()\
\}\
class SalaryCalculator implements Calculator\{\
\}\
class CommissionCalculator implements Calculator\{\
\}\
\'a0\
/////////////////////////////////////////////////////////////\
\\\
This class should be closed for\'a0\cb4 m\cb3 odification ,should be allowed for extension\
class\'a0 WebServiceAdapter\{\
\'a0\'a0 findAll()\{\}\
\'a0\'a0 findById()\{\}\
\'a0\'a0 post()\{\}\
\'a0\'a0 remove()\{\}\
\'a0\'a0 update()\{\}\
\}\
class FetchAdapter extends WebServiceAdapter\
\{\
\'a0 findByEmail()\{\}\
\}\
\'a0\
class AxiosAdapter extends WebServiceAdapter\{\
\'a0\
\'a0\
\}\
///////////////////////////////////////////////////////////////\
Liskov substitution principle:\
\'a0\
"Subtypes\'a0\cb4 m\cb3 ust be substitutable for their base types"\
\'a0\
C#/Java /TypeScript: not in js\
\'a0\
class Animal\{\}\
\'a0\
class Dog exends Animal\{\}\
class Cat extends Animal\{\}\
class Lion extends Animal\{\}\
\'a0\
Dog d=new Dog();\
\'a0\
Animal a =new Dog(); //\
\'a0\
JS Testing:\
\'a0\
var a =\{\}\
\'a0\
a instanceof Object =>True\
\'a0\
class Animal\{\}\
\'a0\
class Dog extends Animal\{\}\
\'a0\
const dog =new Dog();\
\'a0\
console.log(dog instanceof Animal) =>True\
//////////////////////////////////////////////////////////////\
Interface Segregation Principle:\
\'a0\
Clients should not be forced to depend on\'a0\cb4 m\cb3 ethods that they do not use.\
\'a0\
eg:\
In Angular , Life cycle\'a0\cb4 m\cb3 ethods are not grouped inside one single interface, why\
\'a0\'a0The reason is all Component need not implement all life cycle\'a0\cb4 m\cb3 ethods.\
\'a0\
interface OnInit \{\
\'a0 ngOnInit(): void\
\}\
\'a0\
interface OnDestroy \{\
\'a0 ngOnDestroy(): void\
\}\
\'a0\
interface LifeCycles\{\
ngOnInit(): void\
ngOnDestroy(): void\
\}\
\'a0\
class CustomerComponent implements OnInit\{\
ngOnInit()\{\}\
\'a0\
\}\
\'a0\
\'a0\
class OrderComponent implements OnInit,OnDestroy\{\
ngOnInit()\{\}\
ngOnDestroy()\{\}\
\}\
\'a0\
////////////////////////////////////////////////////////////\
\'a0\
Dependency-Inversion Principle\
\'a0\
High-level\'a0\cb4 m\cb3 odules should not depend on low-level\'a0\cb4 m\cb3 odules.\
Both should depend on abstractions.\
Abstractions should not depend on details. Details should\
depend on abstractions.\
\'a0\
Typescript:\
\'a0\
interface Adapter\{\}\
\'a0\
class FireBaseAdapter implements Adapter\{\}\
\'a0\'a0\
class FetchAdapter implements Adapter\{ \}\
\'a0\
\'a0\
class EmployeeService\{\
\'a0\
\'a0\'a0\'a0\'a0constructor(adapter:Adapter)\{\
\'a0\'a0\'a0\'a0 this.adapter = adapter;\
\'a0\'a0 \}\
\}\
new EmployeeService(new FireBaseAdapter())\
new EmployeeService(new FetchAdapter())\
}